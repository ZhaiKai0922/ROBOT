# 数据结构、算法与应用——笔记

## C++回顾

### 1.4 动态存储空间分配

#### 1.4.1 操作符new

​		C++操作符new用来进行动态存储分配，它的值是一个指针。

`int* y`

​		当程序需要这个整数时，就使用下面的语句为这个整数动态分配存储空间

` y = new int`

​		y是对整数指针的引用，而*y是对整数本身的引用

`*y = 10`

​		我们可以把上面三个步骤（声明y，动态存储分配，为*y赋值）合并为以下的形式：

`int* y = new int`

`*y = 10`

或

`int* y = new int(10)`

#### 1.4.2 一维数组

​		本书列举的许多函数都使用了二维数组，这些数组的大小在编译时可能还是未知的，他们随着函数调用的变化而变化，因此，对这些数组只能进行动态分配存储空间。

`float* x = new float[10]`

​		对每个数组元素的访问可以用x[0],x[1],x[2]的形式。

#### 1.4.3 异常处理

​		当计算机没有足够的内存可以分配时。在这样的情况下，操作符new也不会分配内存，而是抛出一个类型为bad_alloc的异常。利用try-catch结构，我们可以捕获这个因new操作失败而引发的异常。

```cpp
float* x;
try{x = new float[10]}
catch(bad_alloc e)
{
    cout << "Out of memory"<<endl;
    exit(1);
}
```

#### 1.4.4 操作符delete

​		动态分配的存储空间不再需要的时候需要把它释放掉。释放的空间可以用来重新动态分配内存。C++操作符delete用来释放由操作符new所分配的空间。下面的语句用来释放分配给*y和一维数组x的空间；

```cpp
delete y;
delete []x;
```

#### 1.4.5 二维数组

......

### 1.5 自有数据类型

#### 1.5.1 类currency

C++语言支持诸如int、float、char这样的数据类型。而本书的许多应用所需要的数据类型是C++不支持的，需要自己定义。定义自有数据类型最灵活的方式就是使用C++的类结构class。假定你想处理货币类型currency的队形，这种对象有三个成员：符号、美元和美分。对这种对象我们想要执行的操作如下：

- 给成员赋值
- 确定成员的值
- 两个对象相加
- 增加成员的值
- 输出

假定用无符号长整形变量dollars，无符号整形变量cents和signType类型变量sign来描述货币对象，其中signType类型的定义如下：

`enum signType{plus, minus};`

......

#### 1.5.3 操作符重载

​		类currency有若干成员函数与C++标准操作符类似。例如，add实施的是+操作，increment实施的是+=操作。使用操作符比定义新的诸如add和increment的成员函数要自然的多。为了使用操作符+和+=，我们进行操作符重载，它可以扩大C++操作符的应用范围，使其操作新的数据类型或类。

非成员函数不能访问currency对象的私有成员。

#### 1.5.4 友元和保护性类成员

​		正如前面所指出的那样，对一个类的私有成员，仅有类的成员函数才能直接访问。可是在一些应用程序中，我们必须给予别的类和函数直接访问该类私有成员的权利。这就需要把这些类和函数声明为该类的友元(friend)。

​		在currency类的示例中，为了便于对操作符<<的重载，我们定义了成员函数output。通过output，下面的函数才能访问私有数据成员amount。

​		如果把`ostream& operator<<`声明为currency类的友元，它就可以直接访问currency类的所有成员（私有和公有），这时就不用另外定义成员函数output了。为了建立友元，我们在currency类的描述中引入friend语句。为了格式统一，friend语句总是紧跟在类标题语句之后，如：

```cpp
class currency{
    friend ostream& operator<< (ostream& out, currency& x);
    
    public:
}
```

​		一个类A从另一个类B派生，A是派生类（derived class）B是基类（base class）。派生类需要访问基类的部分或所有数据成员，为此，C++提供了第三类成员——保护性成员（protected）。保护性成员类似于私有成员，区别在于派生类函数可以访问基类的保护性成员。

​		**派生类不能访问基类的private成员**，只能访问基类中的public 和 protect成员。其中派生类中的成员函数和友元函数与继承方式无关，但是在类外与 继承方式 有关，一般采用同级，因此多数使用public继承。

#### 1.5.5 增加#ifndef、#define 和 #endif

`#ifndef LIADA_LOCALIZATION_DATA_PRETREAT_HPP_`

`#define LIDAR_LOCALIZATION_DATA_PRETREAT_HPP_`

`#endif`

**包含这组语句的代码只编译一次**

### 1.6 异常类

### 1.7 递归函数

​		递归函数就是自己调用自己。在直接递归中，递归函数f的代码包含了调用f的语句，而在间接递归中，递归函数f调用了函数g，g又调用了函数h，如此进行下去，直至又调用了f。在深入探讨C++递归函数之前，我们来考察两个相关的数学概念——数学函数的递归定义和归纳证明。

#### 1.7.1 递归的数学函数

#### 1.7.2 归纳

#### 1.7.3 C++递归函数

......

### 1.8 标准模板库

C++标准模板库，STL是一个容器、适配器、迭代器、函数对象和算法的集合。

### 1.9 什么是测试



## 第2章 程序性能分析

​		所谓程序性能是指运行这个程序所需要的内存和时间的多少。我们用两种方法来确定一个程序的性能，一个是分析方法，另一个是试验方法。在性能分析时，采用分析方法，而在性能测量时，使用实验方法。

​		所谓一个程序的**空间复杂度**是指该程序的运行所需内存的大小。

​		所谓程序的**时间复杂度**是指运行程序所需要的时间。

### 2.2 空间复杂度

#### 2.2.1 空间复杂度的组成

程序所需要的空间主要由以下部分构成：

1. 指令空间
2. 数据空间：数据空间是指所有常量和变量值所需要的存储空间。它由两个部分构成：

- 常量和简单变量 所需要的存储空间
- 动态数组和动态实例等动态对象多需要的空间。

3. 环境栈空间

   ​	环境栈用来保存暂停的函数和方法在恢复运行时所需要的信息。

## 第四章 性能测试

这部分看不太懂......略过......





# 第二部分 数据结构

### 线性表——数组描述

​		STL容器vector list大致相当于线性表的数组描述方法和链式描述方法。STL的类还有其他很多方法。在建立线性表和数组描述和链式描述中，我们使用的函数名和签名与STL代码所使用的相同，这容易转换到STL代码中。

​		





 











