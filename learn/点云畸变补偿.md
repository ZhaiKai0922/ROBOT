# 点云畸变补偿

## 一. 概述

在基于机械雷达的定位系统中，点云畸变补偿是必须要做的事情，因为按照机械雷达的原理，有运动就有畸变。

畸变产生的原因是一帧点云中的点不是在同一个时刻采集的，在采集过程中，雷达随着载体在运动，但是雷达点测量的物体和雷达之间的距离，所以不同激光点的坐标系就不一样了。

解决这一问题，就需要把采集过程中雷达的运动计算出来，并在对应的激光点上补偿这个运动量。

大家接触比较多的运动畸变补偿代码应该是loam里面的那段，这里稍有些不同，首先，雷达的点云输出一般是按照列排列，而此处经过第三方程序对kitty数据进行二次加工后，变成了行排列，这种排列的方式的改变会导致补偿方法有所区别。另一点不同是，loam使用了高频率的imu数据进行补偿，从原理上讲，这样确实更精确，尤其是在高动态的环境下，但是稍显复杂，对于车来讲，运动并不剧烈，所以我们在点云的一个采集周期(100ms)内可以认为它是匀速运动，这样实现起来就简单多了。

## 二. 点云畸变原理

我们更详细的解释一下这个事。

首先要说一帧点云的产生过程。对于kitty数据集来讲，使用的是velodyne HDL 64E。

这个雷达在纵向上排列着64个激光发射器和接收器，也就是说，它一次发射和接收会得到一列64个点。这64个发射器沿着不用的水平角发射，在HDL 64E中，最大的水平角是2°，最小的水平角是-24.8°，中间的水平角均匀变化，相邻的两个发射器的水平角相差大概0.4°。在采集过程中，这一列设备绕着竖直方向旋转，在100ms内旋转一周，在旋转过程中不停的发射和接收，就会得到n列激光点，这些激光点构成了一帧点云。HDL 64E中，这个n是4500，也就是水平方向上分辨率是0.08°。

由于竖直方向上分辨率是0.4°，水平方向上分辨率是0.08°，即竖直方向间隔要比水平方向大很多，所以我们看到的点云都是一圈一圈的。

假设我们把这个雷达放在一个圆柱形的建筑正中心，那么在静止状况下，我们只取64条线中的一条线，那么我们得到的就应该是一个圆环。

## 三. 畸变补偿的方法

我们把这个问题分解一下，补偿可以分为计算和转换两步，如下：

### 1. 计算相对坐标

在匀速模型假设前提下，坐标等于运动乘以时间，所以又可以分解为两步：

- 获取载体运动信息

运动信息在原始数据里已经存在，包括角速度、速度，分别用来计算相对角度和相对位移。而且数据是我们已经做好时间同步的。

- 获取该激光点相对于起始时刻的时间差

由于是顺序扫描，我们可以很容易通过atan2(y, x)来计算该激光点相对于第一个激光点旋转过的角度β，我们知道雷达内部旋转360°用了100ms，那么旋转β角度用多长时间，就了然了。

### 2. 转换激光点

其实就是坐标系乘以向量，坐标系是转换矩阵，向量是转换之前的激光点坐标，这个转换可以先旋转再平移也可以用4乘4矩阵一次性计算。

## 四. 程序设计

通过上面的任务拆解，程序的设计思路就比较清晰了。需要注意的应该就只是程序结构问题。

由于点云补畸变是一个独立的功能，所以我们在models文件夹下新建一个文件夹scan_adjust，用于存放这个功能的类文件，专门用来补偿畸变。这个类需要需要运动信息，通过SetMotionInfo在每次补畸变之前传入。激光点坐标转换在AdjustCloud函数里，具体代码就不贴了，内容和上一部分讲的基本上一致。

我们在front_end_flow.cpp中调用这个类，其实两行程序就搞定了

```cpp
distortion_adjust_ptr_ -> SetMotionInfo(0.1, current_velocity_data_);
distortion_adjust_ptr_ -> AdjustCloud(current_cloud_data_.cloud_ptr, current_cloud_data_.cloud_ptr);
```

 有两点需要注意：

第一点是，在kitty原始数据里，提供了每帧点云的起始采集时刻和终止采集时刻，kitti2bag这个功能包在把数据转成bag文件的过程中，利用起始时刻和终止时刻取了个平均值，即中间时刻，作为这一帧点云的采集时刻，上面的方法其实是把点云全都转到起始时刻上去，所以我们在计算的每个激光点采集时刻上再减去50ms，这样就相当于把一帧点云的坐标系转到中间时刻对应的坐标系上去了。

第二点是，数据中提供的速度是IMU所处位置的速度，而我们要的是激光雷达所处位置的速度，由于这两者并不重合，即存在杆臂，所以在车旋转时他们的速度并不一致，需要按照这两者之间的相对坐标，把速度转到雷达对应的位置上去，这个功能我们放在了sensor_data的velocity_data.cpp，把它作为VelocityData类的成员函数，只要给他一个相对坐标，它就自动把类的内部成员变量转换了，调用时就一行程序

```cpp
current_velocity_data_.TransformCoordinate(lidar_to_imu_);
```

